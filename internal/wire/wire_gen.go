// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package wire

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/google/wire"
	"io"
	"log"
	"mime/multipart"
	"net/http"
	"net/url"
	"os"
	"time"
	"xixunyunsign/service"
	"xixunyunsign/service/impl"
	"xixunyunsign/utils"
	"xixunyunsign/web"
)

import (
	_ "xixunyunsign/service"
)

// Injectors from wire.go:

// InitializeServer creates a new web server with all dependencies injected.
func InitializeServer() (*web.Server, error) {
	db, err := utils.ProvideDB()
	if err != nil {
		return nil, err
	}
	userRepository := utils.NewUserRepository(db)
	authService := impl.NewAuthService(userRepository)
	queryService := impl.NewQueryService(userRepository)
	signService := impl.NewSignService(userRepository)
	handlers := web.NewHandlers(authService, queryService, signService)
	engine := web.SetupRouter(handlers)
	server := web.NewServer(engine)
	return server, nil
}

// InitializeLoginCmdRunner creates a new runner for the login command with dependencies.
func InitializeLoginCmdRunner() (*LoginCmdRunner, error) {
	db, err := utils.ProvideDB()
	if err != nil {
		return nil, err
	}
	userRepository := utils.NewUserRepository(db)
	authService := impl.NewAuthService(userRepository)
	loginCmdRunner := NewLoginCmdRunner(authService)
	return loginCmdRunner, nil
}

// InitializeQueryCmdRunner creates a new runner for the query commands with dependencies.
func InitializeQueryCmdRunner() (*QueryCmdRunner, error) {
	db, err := utils.ProvideDB()
	if err != nil {
		return nil, err
	}
	userRepository := utils.NewUserRepository(db)
	queryService := impl.NewQueryService(userRepository)
	queryCmdRunner := NewQueryCmdRunner(queryService)
	return queryCmdRunner, nil
}

// InitializeSignCmdRunner creates a new runner for the sign command with dependencies.
func InitializeSignCmdRunner() (*SignCmdRunner, error) {
	db, err := utils.ProvideDB()
	if err != nil {
		return nil, err
	}
	userRepository := utils.NewUserRepository(db)
	signService := impl.NewSignService(userRepository)
	signCmdRunner := NewSignCmdRunner(signService)
	return signCmdRunner, nil
}

// InitializePracticeReportCmdRunner creates a new runner for the practice report command.
func InitializePracticeReportCmdRunner() (*PracticeReportCmdRunner, error) {
	db, err := utils.ProvideDB()
	if err != nil {
		return nil, err
	}
	userRepository := utils.NewUserRepository(db)
	practiceReportCmdRunner := NewPracticeReportCmdRunner(userRepository)
	return practiceReportCmdRunner, nil
}

// wire.go:

type RequestPayload struct {
	Contents []Content `json:"contents"`
}

type Response struct {
	Candidates    []Candidate `json:"candidates"`
	UsageMetadata interface{} `json:"usageMetadata"` // 根据需要定义具体类型
	ModelVersion  string      `json:"modelVersion"`
}

type Candidate struct {
	Content      Content `json:"content"`
	FinishReason string  `json:"finishReason"`
	AvgLogprobs  float64 `json:"avgLogprobs"`
}

type Content struct {
	Parts []ContentPart `json:"parts"`
	Role  string        `json:"role"`
}

type ContentPart struct {
	Text string `json:"text"`
}

// LoginCmdRunner holds dependencies for the login command.
type LoginCmdRunner struct {
	AuthService service.AuthService
}

// NewLoginCmdRunner creates a new runner for the login command.
func NewLoginCmdRunner(authService service.AuthService) *LoginCmdRunner {
	return &LoginCmdRunner{AuthService: authService}
}

// QueryCmdRunner holds dependencies for query commands.
type QueryCmdRunner struct {
	QueryService service.QueryService
}

// NewQueryCmdRunner creates a new runner for query commands.
func NewQueryCmdRunner(queryService service.QueryService) *QueryCmdRunner {
	return &QueryCmdRunner{QueryService: queryService}
}

// RunSearchSchool executes the search school logic.
// This method belongs to the QueryCmdRunner.
func (r *QueryCmdRunner) RunSearchSchool(schoolName string) {
	schools, err := r.QueryService.SearchSchool(schoolName)
	if err != nil {
		log.Printf("查询学校失败: %v\n", err)
		return
	}
	if len(schools) == 0 {
		fmt.Println("未找到匹配的学校。")
		return
	}
	jsonData, _ := json.MarshalIndent(schools, "", "  ")
	fmt.Println(string(jsonData))
}

// SignCmdRunner holds dependencies for the sign command.
type SignCmdRunner struct {
	SignService service.SignService
}

// NewSignCmdRunner creates a new runner for the sign command.
func NewSignCmdRunner(signService service.SignService) *SignCmdRunner {
	return &SignCmdRunner{SignService: signService}
}

// PracticeReportCmdRunner holds dependencies for the practice report command.
type PracticeReportCmdRunner struct {
	UserRepo service.UserRepository
}

// NewPracticeReportCmdRunner creates a new runner for the practice report command.
func NewPracticeReportCmdRunner(userRepo service.UserRepository) *PracticeReportCmdRunner {
	return &PracticeReportCmdRunner{UserRepo: userRepo}
}

// MonthReportUploadSelectFile uploads a report file.
func (r *PracticeReportCmdRunner) MonthReportUploadSelectFile(filePath, UserToken string) string {
	apiURL := fmt.Sprintf("https://api.xixunyun.com/file/form?token=%s", UserToken)
	file, err := os.Open(filePath)
	if err != nil {
		log.Printf("Error opening file: %v\n", err)
		return ""
	}
	defer file.Close()
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)
	part, err := writer.CreateFormFile("addFile", fmt.Sprintf("img_%d.jpg", time.Now().Unix()))
	if err != nil {
		log.Printf("Error creating form file: %v\n", err)
		return ""
	}
	_, err = io.Copy(part, file)
	if err != nil {
		log.Printf("Error copying file content: %v\n", err)
		return ""
	}
	if err := writer.WriteField("input_name", "addFile"); err != nil {
		log.Printf("Error writing field input_name: %v\n", err)
		return ""
	}
	if err := writer.WriteField("business", "report"); err != nil {
		log.Printf("Error writing field business: %v\n", err)
		return ""
	}
	err = writer.Close()
	if err != nil {
		log.Printf("Error closing writer: %v\n", err)
		return ""
	}
	req, err := http.NewRequest("POST", apiURL, body)
	if err != nil {
		log.Printf("Error creating request: %v\n", err)
		return ""
	}
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36")
	req.Header.Set("Accept-Language", "zh-CN,zh;q=0.9")
	req.Header.Set("Authorization", UserToken)
	req.Header.Set("Content-Type", writer.FormDataContentType())
	req.Header.Set("Origin", "https://www.xixunyun.com")
	req.Header.Set("Referer", "https://www.xixunyun.com/")
	req.Header.Set("sec-ch-ua", `"Google Chrome";v="131", "Chromium";v="131", "Not_A Brand";v="24"`)
	req.Header.Set("sec-ch-ua-mobile", "?0")
	req.Header.Set("sec-ch-ua-platform", `"Windows"`)
	req.Header.Set("sec-fetch-dest", "empty")
	req.Header.Set("sec-fetch-mode", "cors")
	req.Header.Set("sec-fetch-site", "same-site")
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		log.Printf("Error sending request: %v\n", err)
		return ""
	}
	defer resp.Body.Close()
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Printf("Error reading response body: %v\n", err)
		return ""
	}
	log.Printf("Upload Response Body: %s\n", string(respBody))
	var responseBodyStruct struct {
		Code    int    `json:"code"`
		Message string `json:"message"`
		Data    struct {
			URI string `json:"uri"`
		} `json:"data"`
	}
	err = json.Unmarshal(respBody, &responseBodyStruct)
	if err != nil {
		log.Printf("Error parsing upload response body: %v\n", err)
		return ""
	}
	if responseBodyStruct.Data.URI != "" {
		return responseBodyStruct.Data.URI
	}
	return ""
}

// UploadImages gets user token and calls MonthReportUploadSelectFile.
func (r *PracticeReportCmdRunner) UploadImages(account, filePath string) string {
	token, _, _, err := r.UserRepo.GetUser(account)
	if err != nil || token == "" {
		log.Printf("未找到账号 %s 的 token，请先登录。\n", account)
		return ""
	}
	return r.MonthReportUploadSelectFile(filePath, token)
}

// GenerateContent generates report content using Gemini API.
// It now accepts month as a parameter.
func (r *PracticeReportCmdRunner) GenerateContent(role, apiKey string, month int8) (string, error) {
	apiURL := fmt.Sprintf("https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=%s", apiKey)

	payload := RequestPayload{
		Contents: []Content{
			{
				Role: "user",
				Parts: []ContentPart{
					{Text: fmt.Sprintf("我是%s。现在要求我回答作为第%d个月的实习报告月报的回复。以替换content里的内容返回给我，以api的形式返回给我，不要回复其他的任何信息，不要```json和\\n", role, month)},
				},
			},
			{
				Role: "user",
				Parts: []ContentPart{
					{Text: `[{\"title\":\"实习工作具体情况及实习任务完成情况\",\"content\":\"\",\"require\":\"1\",\"sort\":1},{\"title\":\"主要收获及工作成绩\",\"content\":\"\",\"require\":\"0\",\"sort\":2},{\"title\":\"工作中的问题及需要老师的指导帮助\",\"content\":\"\",\"require\":\"0\",\"sort\":3}]"}`},
				},
			},
		},
	}
	jsonData, err := json.Marshal(payload)
	if err != nil {
		return "", fmt.Errorf("Failed to serialize JSON payload: %v", err)
	}
	req, err := http.NewRequest("POST", apiURL, bytes.NewBuffer(jsonData))
	if err != nil {
		return "", fmt.Errorf("Failed to create HTTP request: %v", err)
	}
	req.Header.Set("Content-Type", "application/json")
	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return "", fmt.Errorf("HTTP request failed: %v", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return "", fmt.Errorf("HTTP request failed, status: %d, body: %s", resp.StatusCode, string(body))
	}
	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("Failed to read response body: %v", err)
	}
	// Use locally defined struct
	var responseData Response
	if err := json.Unmarshal(bodyBytes, &responseData); err != nil {
		return "", fmt.Errorf("Failed to parse response JSON: %v", err)
	}
	if len(responseData.Candidates) == 0 || len(responseData.Candidates[0].Content.Parts) == 0 {
		return "", fmt.Errorf("Response did not contain any content")
	}
	generatedText := responseData.Candidates[0].Content.Parts[0].Text
	return generatedText, nil
}

// ReportsMonth submits the monthly report.
func (r *PracticeReportCmdRunner) ReportsMonth(account, businessType, startDate, endDate, content, attachment string) {
	token, _, _, err := r.UserRepo.GetUser(account)
	if err != nil || token == "" {
		log.Printf("未找到账号 %s 的 token，请先登录。\n", account)
		return
	}
	apiURL := fmt.Sprintf("https://api.xixunyun.com/Reports/StudentOperator?token=%s", token)
	formData := url.Values{}
	formData.Set("business_type", businessType)
	formData.Set("start_date", startDate)
	formData.Set("end_date", endDate)
	formData.Set("content", content)
	formData.Set("attachment", fmt.Sprintf("%s", attachment))
	req, err := http.NewRequest("POST", apiURL, bytes.NewBufferString(formData.Encode()))
	if err != nil {
		log.Println("Error creating request:", err)
		return
	}
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36")
	req.Header.Set("Accept", "application/json, text/javascript, */*; q=0.01")
	req.Header.Set("Accept-Encoding", "gzip, deflate, br, zstd")
	req.Header.Set("sec-ch-ua-platform", "\"Windows\"")
	req.Header.Set("authorization", token)
	req.Header.Set("sec-ch-ua", `"Google Chrome";v="131", \"Chromium\";v="131", \"Not_A Brand\";v="24"`)
	req.Header.Set("content-type", "application/x-www-form-urlencoded; charset=UTF-8")
	req.Header.Set("sec-ch-ua-mobile", "?0")
	req.Header.Set("origin", "https://www.xixunyun.com")
	req.Header.Set("sec-fetch-site", "same-site")
	req.Header.Set("sec-fetch-mode", "cors")
	req.Header.Set("sec-fetch-dest", "empty")
	req.Header.Set("referer", "https://www.xixunyun.com/")
	req.Header.Set("accept-language", "zh-CN,zh;q=0.9")
	req.Header.Set("priority", "u=1, i")
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		log.Println("Error executing request:", err)
		return
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Println("Error reading response body:", err)
		return
	}
	var responseBodyStruct struct {
		Code    int    `json:"code"`
		Message string `json:"message"`
	}
	err = json.Unmarshal(body, &responseBodyStruct)
	if err != nil {
		log.Println("Error parsing response body:", err)
		return
	}
	log.Printf("Report Submit Code: %d\n", responseBodyStruct.Code)
	log.Printf("Report Submit Message: %s\n", responseBodyStruct.Message)
}

// RepositorySet provides database and user repository implementations.
var RepositorySet = wire.NewSet(utils.ProvideDB, utils.NewUserRepository)

// ServiceSet provides service implementations, depending on repositories.
var ServiceSet = wire.NewSet(impl.NewAuthService, impl.NewQueryService, impl.NewSignService)

// HandlerSet provides the web handlers, depending on services.
var HandlerSet = wire.NewSet(web.NewHandlers)

// RouterSet provides the Gin engine, depending on handlers.
var RouterSet = wire.NewSet(web.SetupRouter)

// ServerSet provides the web server, depending on the router.
var ServerSet = wire.NewSet(web.NewServer)
